#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Gerador de Prompts para Flashcards do Anki - Vers√£o Aprimorada
Gera prompts personalizados incluindo automaticamente o conte√∫do dos arquivos .md
das disciplinas acad√™micas (anota√ß√µes, exerc√≠cios e simulados).
"""

import os
import sys
import shutil
from datetime import datetime
from pathlib import Path

def clean_old_prompts(prompts_dir):
    """
    Remove todos os arquivos .txt do diret√≥rio de prompts, se ele existir.
    
    Args:
        prompts_dir (str): Caminho para o diret√≥rio de prompts
    """
    if os.path.exists(prompts_dir):
        print(f"üßπ Iniciando a limpeza dos prompts antigos em '{prompts_dir}'...")
        removed_count = 0
        
        for filename in os.listdir(prompts_dir):
            if filename.endswith(".txt"):
                file_path = os.path.join(prompts_dir, filename)
                try:
                    os.remove(file_path)
                    print(f"  ‚úÖ Removido: {filename}")
                    removed_count += 1
                except OSError as e:
                    print(f"  ‚ùå Erro ao remover {file_path}: {e}")
        
        print(f"üìä Total de arquivos removidos: {removed_count}")
    else:
        print(f"üìÅ O diret√≥rio '{prompts_dir}' n√£o existe, ser√° criado.")

def read_markdown_file(file_path):
    """
    L√™ o conte√∫do de um arquivo Markdown.
    
    Args:
        file_path (str): Caminho para o arquivo
        
    Returns:
        str: Conte√∫do do arquivo ou mensagem de erro
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read().strip()
            return content if content else "[Arquivo vazio]"
    except UnicodeDecodeError:
        try:
            # Tenta com encoding alternativo
            with open(file_path, 'r', encoding='latin-1') as f:
                content = f.read().strip()
                return content if content else "[Arquivo vazio]"
        except Exception as e:
            return f"[Erro ao ler arquivo: {str(e)}]"
    except Exception as e:
        return f"[Erro ao ler arquivo: {str(e)}]"

def extract_discipline_content(discipline_path):
    """
    Extrai todo o conte√∫do dos arquivos .md das pastas anotacoes, exercicios e simulados.
    
    Args:
        discipline_path (str): Caminho da disciplina
        
    Returns:
        dict: Conte√∫do organizado por categoria
    """
    content = {
        'anotacoes': [],
        'exercicios': [],
        'simulados': [],
        'total_files': 0,
        'total_characters': 0
    }
    
    # Pastas a serem escaneadas
    folders_to_scan = ['anotacoes', 'exercicios', 'simulados']
    
    for folder_name in folders_to_scan:
        folder_path = os.path.join(discipline_path, folder_name)
        
        if os.path.exists(folder_path):
            print(f"  üìÇ Escaneando pasta: {folder_name}")
            
            try:
                files = [f for f in os.listdir(folder_path) if f.endswith('.md') and not f.startswith('.')]
                files.sort()  # Ordena alfabeticamente
                
                for filename in files:
                    file_path = os.path.join(folder_path, filename)
                    
                    if os.path.isfile(file_path):
                        print(f"    üìÑ Lendo: {filename}")
                        
                        file_content = read_markdown_file(file_path)
                        
                        content[folder_name].append({
                            'filename': filename,
                            'content': file_content,
                            'path': file_path
                        })
                        
                        content['total_files'] += 1
                        content['total_characters'] += len(file_content)
                        
            except PermissionError as e:
                print(f"    ‚ö†Ô∏è  Sem permiss√£o para acessar {folder_path}: {e}")
            except Exception as e:
                print(f"    ‚ùå Erro ao escanear {folder_path}: {e}")
        else:
            print(f"  üìÇ Pasta n√£o encontrada: {folder_name}")
    
    return content

def format_content_for_prompt(content, discipline_name):
    """
    Formata o conte√∫do extra√≠do para inclus√£o no prompt.
    
    Args:
        content (dict): Conte√∫do extra√≠do da disciplina
        discipline_name (str): Nome da disciplina
        
    Returns:
        str: Conte√∫do formatado para o prompt
    """
    if content['total_files'] == 0:
        return "‚ö†Ô∏è **Nenhum arquivo .md encontrado nas pastas especificadas.**"
    
    formatted_sections = []
    
    # Mapeamento de nomes de pastas para t√≠tulos
    section_titles = {
        'anotacoes': 'üìù Anota√ß√µes de Aula',
        'exercicios': 'üîß Exerc√≠cios e Pr√°ticas',
        'simulados': 'üéØ Simulados e Avalia√ß√µes'
    }
    
    for section_key, section_title in section_titles.items():
        if content[section_key]:
            formatted_sections.append(f"\n## {section_title}")
            formatted_sections.append(f"*Total de {len(content[section_key])} arquivo(s)*\n")
            
            for file_info in content[section_key]:
                filename = file_info['filename']
                file_content = file_info['content']
                
                # Adiciona separador visual
                formatted_sections.append(f"### üìÑ {filename}")
                formatted_sections.append("```")
                formatted_sections.append(file_content)
                formatted_sections.append("```\n")
    
    # Adiciona estat√≠sticas
    stats_section = f"""
## üìä Resumo do Conte√∫do Dispon√≠vel
- **Total de arquivos processados:** {content['total_files']}
- **Total de caracteres:** {content['total_characters']:,}
- **Arquivos por categoria:**
  - Anota√ß√µes: {len(content['anotacoes'])}
  - Exerc√≠cios: {len(content['exercicios'])}
  - Simulados: {len(content['simulados'])}
"""
    
    return stats_section + "\n" + "\n".join(formatted_sections)

def generate_enhanced_prompt(discipline_name, semester_name, discipline_path, content):
    """
    Gera um prompt completo com todo o conte√∫do da disciplina inclu√≠do.
    
    Args:
        discipline_name (str): Nome da disciplina
        semester_name (str): Nome do semestre
        discipline_path (str): Caminho da disciplina
        content (dict): Conte√∫do extra√≠do da disciplina
        
    Returns:
        str: Prompt completo formatado
    """
    
    # Formata o conte√∫do para inclus√£o no prompt
    formatted_content = format_content_for_prompt(content, discipline_name)
    
    # Gera sugest√µes de t√≥picos
    topic_suggestions = get_topic_suggestions(discipline_name)
    
    prompt_content = f"""# üé¥ Prompt Completo para Gera√ß√£o de Flashcards Anki

## üéØ Objetivo
Voc√™ √© um especialista em educa√ß√£o e flashcards do Anki. Sua tarefa √© criar um conjunto completo de flashcards de alta qualidade para a disciplina de **"{discipline_name}"**, do **{semester_name.replace('-', ' ').replace('Semestre', 'semestre').capitalize()}**.

## üìö Informa√ß√µes da Disciplina
- **Disciplina:** {discipline_name}
- **Per√≠odo:** {semester_name.replace('-', ' ').capitalize()}
- **Total de arquivos processados:** {content['total_files']}
- **Total de conte√∫do:** {content['total_characters']:,} caracteres
- **Gerado em:** {datetime.now().strftime('%d/%m/%Y √†s %H:%M:%S')}

## üéØ Instru√ß√µes Espec√≠ficas

### üìã Formato dos Flashcards
Use EXATAMENTE este formato para cada flashcard:

```
Pergunta: [Sua pergunta clara e concisa]
Resposta: [Resposta objetiva e completa]

---
```

### üîç Crit√©rios de Qualidade
1. **Clareza:** Cada pergunta deve focar em UM conceito espec√≠fico
2. **Concis√£o:** Respostas diretas, sem redund√¢ncias
3. **Relev√¢ncia:** Baseado exclusivamente no conte√∫do fornecido abaixo
4. **Progressividade:** Do b√°sico ao avan√ßado
5. **Aplicabilidade:** Inclua exemplos pr√°ticos quando dispon√≠veis no material

### üìä Quantidade e Estrat√©gia
- **Meta:** 20-40 flashcards no total (baseado na quantidade de conte√∫do)
- **Priorize:** Conceitos que aparecem m√∫ltiplas vezes no material
- **Inclua:** Defini√ß√µes, procedimentos, compara√ß√µes e aplica√ß√µes pr√°ticas
- **Evite:** Perguntas muito espec√≠ficas ou decorativas

### üé≤ Tipos de Perguntas
- **Defini√ß√µes:** "O que √©...?", "Defina...", "Qual o conceito de...?"
- **Compara√ß√µes:** "Qual a diferen√ßa entre X e Y?", "Compare..."
- **Procedimentos:** "Como fazer...?", "Quais os passos para...?"
- **Aplica√ß√µes:** "Quando usar...?", "Em que situa√ß√£o...?", "Para que serve...?"
- **An√°lise:** "Por que...?", "Qual a consequ√™ncia de...?", "Qual a import√¢ncia de...?"

## üí° Sugest√µes de T√≥picos
{topic_suggestions}

## üìù Instru√ß√µes Cr√≠ticas de Sa√≠da
1. **APENAS FLASHCARDS:** Forne√ßa SOMENTE a lista de flashcards, nada mais
2. **SEM TEXTO ADICIONAL:** N√£o inclua introdu√ß√µes, explica√ß√µes ou coment√°rios
3. **FORMATO EXATO:** Use exatamente o formato especificado acima
4. **SEPARA√á√ÉO CLARA:** Use "---" entre cada flashcard
5. **BASE NO CONTE√öDO:** Use APENAS as informa√ß√µes fornecidas abaixo

---

# üìñ CONTE√öDO COMPLETO DA DISCIPLINA

{formatted_content}

---

# ‚ö° INSTRU√á√ïES FINAIS

Com base em TODO o conte√∫do acima, crie agora os flashcards seguindo rigorosamente:
- O formato especificado
- Apenas informa√ß√µes do conte√∫do fornecido
- Foco em conceitos principais e aplica√ß√µes pr√°ticas
- Perguntas claras e respostas completas

**IMPORTANTE:** Responda APENAS com os flashcards no formato especificado, sem qualquer texto adicional."""
    
    return prompt_content

def get_topic_suggestions(discipline_name):
    """
    Gera sugest√µes de t√≥picos automaticamente baseadas no nome da disciplina.
    
    Args:
        discipline_name (str): Nome da disciplina
        
    Returns:
        str: Lista formatada de sugest√µes de t√≥picos
    """
    # T√≥picos gen√©ricos que se aplicam a qualquer disciplina
    generic_topics = [
        f'Conceitos fundamentais de {discipline_name}',
        f'Defini√ß√µes e terminologias importantes',
        f'M√©todos e t√©cnicas principais',
        f'Aplica√ß√µes pr√°ticas e exemplos',
        f'Resolu√ß√£o de problemas e exerc√≠cios',
        f'Casos especiais e situa√ß√µes excepcionais'
    ]
    
    # Formata a lista
    formatted_topics = "\n".join([f"  - {topic}" for topic in generic_topics])
    return formatted_topics

def generate_anki_prompts(root_path):
    """
    Gera prompts completos para criar flashcards do Anki, incluindo todo o conte√∫do
    dos arquivos .md das disciplinas encontradas.
    
    Args:
        root_path (str): Caminho raiz do reposit√≥rio
    """
    if not os.path.exists(root_path):
        print(f"‚ùå Erro: O caminho '{root_path}' n√£o existe.")
        return

    output_dir = os.path.join(root_path, "anki_prompts")
    
    # 1. Limpa os prompts antigos antes de gerar os novos
    clean_old_prompts(output_dir)

    # Garante que a pasta de prompts exista
    os.makedirs(output_dir, exist_ok=True)
    
    print(f"\nüöÄ Iniciando a gera√ß√£o de prompts completos para flashcards do Anki...")
    print(f"üìÅ Diret√≥rio base: {root_path}")
    print(f"üîç Buscando pastas: anotacoes, exercicios, simulados")

    disciplines_found = 0
    prompts_generated = 0
    total_files_processed = 0

    for dirpath, dirnames, filenames in os.walk(root_path):
        # Ignora pastas ocultas e a pasta de prompts
        dirnames[:] = [d for d in dirnames if not d.startswith('.') and d != "anki_prompts"]

        # Verifica se √© uma pasta de disciplina (tem pelo menos uma das pastas esperadas)
        expected_folders = ['anotacoes', 'exercicios', 'simulados']
        has_expected_folders = any(folder in dirnames for folder in expected_folders)
        
        if has_expected_folders:
            disciplines_found += 1
            
            discipline_name = os.path.basename(dirpath).replace('-', ' ').replace('_', ' ').title()
            semester_name = os.path.basename(os.path.dirname(dirpath))
            
            print(f"\nüìö Processando: {discipline_name}")
            print(f"üéì Semestre: {semester_name}")
            
            # Extrai todo o conte√∫do da disciplina
            content = extract_discipline_content(dirpath)
            total_files_processed += content['total_files']
            
            print(f"üìä Arquivos processados: {content['total_files']}")
            print(f"üìè Total de caracteres: {content['total_characters']:,}")
            
            if content['total_files'] > 0:
                # Gera o prompt completo com conte√∫do
                prompt_content = generate_enhanced_prompt(
                    discipline_name, 
                    semester_name, 
                    dirpath, 
                    content
                )
                
                # Cria o arquivo com o prompt
                safe_filename = "".join(c for c in os.path.basename(dirpath) if c.isalnum() or c in ('-', '_'))
                output_filename = os.path.join(output_dir, f"{safe_filename}_anki_prompt_completo.txt")
                
                try:
                    with open(output_filename, 'w', encoding='utf-8') as f:
                        f.write(prompt_content)
                    
                    print(f"  ‚úÖ Prompt gerado: {os.path.basename(output_filename)}")
                    print(f"  üìÑ Tamanho do arquivo: {len(prompt_content):,} caracteres")
                    prompts_generated += 1
                    
                except IOError as e:
                    print(f"  ‚ùå Erro ao criar arquivo: {e}")
            else:
                print(f"  ‚ö†Ô∏è  Nenhum arquivo .md encontrado - prompt n√£o gerado")
    
    # Relat√≥rio final
    print(f"\n{'='*60}")
    print(f"üéâ PROCESSO CONCLU√çDO!")
    print(f"{'='*60}")
    print(f"üìö Disciplinas encontradas: {disciplines_found}")
    print(f"üìù Prompts gerados com sucesso: {prompts_generated}")
    print(f"üìÑ Total de arquivos .md processados: {total_files_processed}")
    
    if prompts_generated > 0:
        print(f"üìÅ Localiza√ß√£o dos prompts: {output_dir}")
        print(f"\nüí° COMO USAR:")
        print(f"   1. Abra os arquivos '_anki_prompt_completo.txt' na pasta 'anki_prompts'")
        print(f"   2. Copie TODO o conte√∫do do arquivo")
        print(f"   3. Cole em sua IA preferida (ChatGPT, Claude, etc.)")
        print(f"   4. A IA criar√° os flashcards baseados no conte√∫do real da disciplina")
        print(f"   5. Importe os flashcards gerados no Anki")
        
        print(f"\nüéØ VANTAGENS:")
        print(f"   ‚úÖ Conte√∫do completo inclu√≠do automaticamente")
        print(f"   ‚úÖ N√£o precisa copiar/colar manualmente")
        print(f"   ‚úÖ Flashcards baseados no material real")
        print(f"   ‚úÖ Prompts otimizados para cada disciplina")
    else:
        print(f"\n‚ö†Ô∏è  NENHUM PROMPT FOI GERADO")
        print(f"   Verifique se a estrutura est√° correta:")
        print(f"   üìÅ YYYY-N-Semestre/disciplina/anotacoes/*.md")
        print(f"   üìÅ YYYY-N-Semestre/disciplina/exercicios/*.md")
        print(f"   üìÅ YYYY-N-Semestre/disciplina/simulados/*.md")

def main():
    """
    Fun√ß√£o principal do programa.
    """
    print("üé¥ Gerador de Prompts Completos para Flashcards do Anki")
    print("üìñ Vers√£o Aprimorada - Inclui conte√∫do autom√°tico dos arquivos .md")
    print("=" * 70)
    
    # Detecta o diret√≥rio atual
    current_dir = os.path.dirname(os.path.abspath(__file__))
    
    try:
        generate_anki_prompts(current_dir)
    except KeyboardInterrupt:
        print(f"\n\n‚ö†Ô∏è  Processo interrompido pelo usu√°rio.")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {e}")
        print(f"üí° Dica: Verifique se h√° arquivos .md corrompidos ou com encoding especial")
        sys.exit(1)

if __name__ == "__main__":
    main()
